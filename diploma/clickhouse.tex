\section{Разбор запроса в ClickHouse} \label{chap:clickhouse}
ClickHouse поддерживает собственный диалект SQL. Для разбора исходного текстового запроса в ClickHouse используется лексер и парсер, написанные вручную на C++. В рамках данной работы в основном будут использованы знания об устройстве ClickHouse AST, но для полноты картины ниже представлен краткий обзор подхода ClickHouse к разбору рапроса. 

К описанию архитекуры приложены фрагменты кода ее описывающие. Для большей лаконичности, код упрощен и не содержит строк, не существенных для общего понимания архитектуры. Полноценные версии используемых классов и методов могут быть найдены в репозитории ClickHouse \cite{ch_repo}.  

\subsection{Лексический анализ в ClickHouse}

Лексический анализ в ClickHouse осуществляется объектом класса \mintinline{c++}{ Lexer } (см. Листинг \ref{ch:lexer_cpp}), конструируимщся от указателей на границы исходного запроса. Основным методом лексера является \mintinline{c++}{ Lexer::nextToken }, который итеративно возвращает последовательность токенов. Сам алгоритм токенизации имплементирован в методе \mintinline{c++}{ Lexer::nextTokenImpl }. Токен представляет собой структуру (см. Листинг \ref{ch:token_cpp}), содержащую тип токена (поле \mintinline{c++}{ Token::type }) и подстроку исходного запроса, которой он соответствует (поля \mintinline{c++}{ Token::begin }, \mintinline{c++}{ Token::end }). Полученная последовательность токенов в дальнешем используется парсером для конструирования \textit{абстрактного синтаксического дерева ClickHouse} (в ниже и в дальнейшем \textbf{ClickHouse AST}).

\begin{code}
    \captionof{listing}{Структура лексера в ClickHouse}
    \label{ch:lexer_cpp}
    \begin{minted}[frame=single, fontsize=\footnotesize]{c++}
class Lexer
{
public:
    Lexer(const char * begin_, const char * end_,
        size_t max_query_size_ = 0);
    Token nextToken();
private:
    const char * const begin;
    const char * pos;
    const char * const end;

    Token nextTokenImpl();
};
    \end{minted}
\end{code}

\begin{code}
    \captionof{listing}{Структура токена в ClickHouse}
    \label{ch:token_cpp}
    \begin{minted}[frame=single, fontsize=\footnotesize]{c++}
enum class TokenType
{
    Number,
    QuotedIdentifier,
    Plus,
    // etc.
};

struct Token
{
    TokenType type;
    const char * begin;
    const char * end;
        
    // methods (helpers) ...
};
\end{minted}
\end{code}

\subsection{Устройство ClickHouse AST}
Абстрактное синтаксическое дерево в ClickHouse состоит из вершин, реализующих интерфейс \mintinline{c++}{ IAST }, содержащий информацию о связях с непосредственными потомками (дочерними вершинами) и вспомогательные методы, общие для всех вершин (см. Листинг \ref{ch:IAST_cpp}). \mintinline{c++}{ ASTPtr } - умный указатель на вершину произвольного типа (тип \mintinline{c++}{ std::shared_ptr<IAST> })

\begin{code}
    \captionof{listing}{Структура интерфейса IAST}
    \label{ch:IAST_cpp}
    \begin{minted}[frame=single, fontsize=\footnotesize]{c++}
class IAST;

using ASTPtr = std::shared_ptr<IAST>;

class IAST
{
public:
    std::vector<ASTPtr> children;
    virtual ASTPtr clone() const = 0;
    std::string dumpTree(size_t indent = 0) const;
    
    // other common methods
};
\end{minted}
\end{code}
Поскольку \mintinline{c++}{ IAST } является абстрактным классом, в действительности классы вершин AST наследуют \mintinline{c++}{ IAST }. В качестве примера рассмотрим \mintinline{c++}{ ASTLiteral }, описывающий вершину, которая соответствует \textit{литералу} (числу, строке, \textit{TRUE}, \textit{FALSE}, \textit{NULL} и т. д.)

\begin{code}
    \captionof{listing}{Наследник интерфейса IST на примере литерала}
    \label{ch:ASTLiteral_cpp}
    \begin{minted}[frame=single, fontsize=\footnotesize]{c++}
class ASTWithAlias : public IAST
{
public:
    String alias;

    // methods (helpers)
};

class ASTLiteral : public ASTWithAlias
{
public:
    explicit ASTLiteral(Field value_) 
            : value(std::move(value_)) {}
    Field value; // can contain int, float, string, NULL etc.

    // methods (helpers)
};        
    \end{minted}
\end{code}

Выше (см. Листинг \ref{ch:ASTLiteral_cpp}) приведена структура двух классов, наследующих \mintinline{c++}{ IAST }. \mintinline{c++}{ ASTWithAlias } описывает интерфейс сущности, которая может иметь \textit{alias} (например \mintinline{sql}{ SELECT 1 as alias_one }). Его, в свою очередь, наследует класс \mintinline{c++}{ ASTLiteral }, содержащий поле \mintinline{c++}{ ASTLiteral::value }, которое может хранить значение литерала произвольного типа (из списка поддерживаемых ClickHouse).

Всего в кодовой базе ClickHouse описано более ста различных типов вершин, каждый из которых отвечает за специфичную часть запроса

\subsection{Синтаксический анализ в ClickHouse}
Для конструирования AST ClickHouse использует парсер, представляющий собой множество классов, реализующих интерфейс \mintinline{c++}{ Parser } (см. Листинг \ref{ch:IParser_cpp}). Разбор осуществляется посредством метода \mintinline{c++}{ IParser::parse }, принимающий на вход итератор по потоку токенов (структура \mintinline{c++}{ IParser::Pos }) и записывающий сконструированое AST во второй аргумент.

Поскольку \mintinline{c++}{ IParser } является абстрактным классом, в действительности разбор осуществляется объектами классов, наследующих \mintinline{c++}{ IParser }. Архитектура парсера устроена так, чтобы приблизительно соответствовать имеющимся типам вершин AST (описаны выше).
\begin{code}
    \captionof{listing}{Интерфейс парсера}
    \label{ch:IParser_cpp}
    \begin{minted}[frame=single, fontsize=\footnotesize]{c++}
class IParser
{
public:
    // can iterate over stream of tokens
    struct Pos : TokenIterator;
    virtual bool parse(Pos & pos, ASTPtr & node,
            Expected & expected) = 0;

    // methods (helpers)
};

    \end{minted}
\end{code}

\subsection{Интерпретация ClickHouse AST}
Результатом синтаксического анализа является \mintinline{c++}{ ASTPtr }, который представляет собой корень дерева, соответсвующего полученному запросу. После конструирования, AST используется \textit{интерпретатором} для непосредственного исполнения запроса. По аналогии с парсерами, интерпретаторы наследуют класс \mintinline{c++}{ IInterpreter } и примерно соответсвуют имеющимся типам AST. Интерфейс \mintinline{c++}{ IInterpreter } содержит метод \mintinline{c++}{ IInterpreter::execute }, осуществляющий исполнение запроса, а каждый конкретный интерпретатор конструируется от \mintinline{c++}{ ASTPtr }, данные которого будут использованы в процессе исполнения. Ниже приведена примерная архитектура интерфейса интерпретатора и реализации интерпретатора запроса \mintinline{sql}{ DROP } (см. Листинг \ref{ch:IInterpreter_cpp}).
\begin{code}
    \captionof{listing}{Интерфейс интерпретатора и пример его наследника}
    \label{ch:IInterpreter_cpp}
    \begin{minted}[frame=single, fontsize=\footnotesize]{c++}
class IInterpreter
{
public:
    virtual BlockIO execute() = 0;
    
    // other common methods
}

class InterpreterDropQuery : 
    public IInterpreter, WithMutableContext
{
public:
    InterpreterDropQuery(const ASTPtr & query_ptr_, 
        ContextMutablePtr context_);
    
    /// Drop table or database.
    BlockIO execute() override;

    // methods (helpers)
};
    \end{minted}
\end{code}

Интерпретатор запроса работает с ClickHouse AST, поэтому задача по внедрению поддержки диалекта MySQL сводится к тому, чтобы по запросу на диалекте MySQL получить ClickHouse AST, соответствующее ему \textit{семантически} (результат исполнения адекватен запросу). 
